{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Rodux is a central state management library based on Dan Abramov's Redux library for JavaScript. It exposes a very similar API and implements nearly identical semantics.</p> <p>This documentation is based on the structure of Redux's documentation, but is a work in progress. Many things from Redux also apply to Rodux, but if you find anything missing or incorrect, open an issue on GitHub!</p> <p>Info</p> <p>This documentation assumes some familiarity with Lua. If you're new to Lua, Programming in Lua by Roberto Ierusalimschy is a good introduction, and the first edition (for Lua 5.0) is available online for free.</p>"},{"location":"api-reference/","title":"Rodux API Reference","text":""},{"location":"api-reference/#roduxstore","title":"Rodux.Store","text":"<p>The Store class is the core piece of Rodux. It is the state container that you create and use.</p>"},{"location":"api-reference/#storenew","title":"Store.new","text":"<pre><code>Store.new(reducer, [initialState, [middlewares, [errorReporter, [devtools]]]]) -&gt; Store\n</code></pre> <p>Creates and returns a new Store.</p> <ul> <li><code>reducer</code> is the store's root reducer function, and is invoked whenever an action is dispatched. It must be a pure function.</li> <li><code>initialState</code> is the store's initial state. This should be used to load a saved state from storage.</li> <li><code>middlewares</code> is a list of middleware functions to apply each time an action is dispatched to the store.</li> <li><code>errorReporter</code> is a error reporter object that allows custom handling of errors that occur during different phases of the store's updates</li> <li><code>devtools</code> is a custom object that you can provide in order to profile, log, or control the store for testing and debugging purposes</li> </ul> <p>The store will automatically dispatch an initialization action with a <code>type</code> of <code>@@INIT</code>.</p> <p>Note</p> <p>The initialization action does not pass through any middleware prior to reaching the reducer.</p>"},{"location":"api-reference/#storechanged","title":"Store.changed","text":"<pre><code>store.changed:connect(function(newState, oldState)\n    -- do something with newState or oldState\nend)\n</code></pre> <p>A Signal that is fired when the store's state is changed up to once per frame.</p> <p>Warning</p> <p>Multiple actions can be grouped together into one changed event!</p> <p>Danger</p> <p>Do not yield within any listeners on <code>changed</code>; an error will be thrown.</p>"},{"location":"api-reference/#storedispatch","title":"Store:dispatch","text":"<pre><code>store:dispatch(action) -&gt; nil\n</code></pre> <p>Dispatches an action. The action will travel through all of the store's middlewares before reaching the store's reducer.</p> <p>Unless handled by middleware, <code>action</code> must contain a <code>type</code> field to indicate what type of action it is. No other fields are required.</p>"},{"location":"api-reference/#storegetstate","title":"Store:getState","text":"<pre><code>store:getState() -&gt; table\n</code></pre> <p>Gets the store's current state.</p> <p>Warning</p> <p>Do not modify this state! Doing so will cause serious bugs your code!</p>"},{"location":"api-reference/#storedestruct","title":"Store:destruct","text":"<pre><code>store:destruct() -&gt; nil\n</code></pre> <p>Destroys the store, cleaning up its connections.</p> <p>Danger</p> <p>Attempting to use the store after <code>destruct</code> has been called will cause problems.</p>"},{"location":"api-reference/#storeflush","title":"Store:flush","text":"<pre><code>store:flush() -&gt; nil\n</code></pre> <p>Flushes the store's pending actions, firing the <code>changed</code> event if necessary.</p> <p>Info</p> <p><code>flush</code> is called by Rodux automatically every frame and usually doesn't need to be called manually.</p>"},{"location":"api-reference/#signal","title":"Signal","text":"<p>The Signal class in Rodux represents a simple, predictable event that is controlled from within Rodux. It cannot be created outside of Rodux, but is used as <code>Store.changed</code>.</p>"},{"location":"api-reference/#signalconnect","title":"Signal:connect","text":"<pre><code>signal:connect(listener) -&gt; { disconnect }\n</code></pre> <p>Connects a listener to the signal. The listener will be invoked whenever the signal is fired.</p> <p><code>connect</code> returns a table with a <code>disconnect</code> function that can be used to disconnect the listener from the signal.</p>"},{"location":"api-reference/#helper-functions","title":"Helper functions","text":"<p>Rodux supplies some helper functions to make creating complex reducers easier.</p>"},{"location":"api-reference/#roduxcombinereducers","title":"Rodux.combineReducers","text":"<p>A helper function that can be used to combine multiple reducers into a new reducer.</p> <pre><code>local reducer = combineReducers({\n    key1 = reducer1,\n    key2 = reducer2,\n})\n</code></pre> <p><code>combineReducers</code> is functionally equivalent to writing:</p> <pre><code>local function reducer(state, action)\n    return {\n        key1 = reducer1(state.key1, action),\n        key2 = reducer2(state.key2, action),\n    }\nend\n</code></pre>"},{"location":"api-reference/#roduxcreatereducer","title":"Rodux.createReducer","text":"<pre><code>Rodux.createReducer(initialState, actionHandlers) -&gt; reducer\n</code></pre> <p>A helper function that can be used to create reducers.</p> <p>Unlike JavaScript, Lua has no <code>switch</code> statement, which can make writing reducers that respond to lots of actions clunky.</p> <p>Reducers often have a structure that looks like this:</p> <pre><code>local initialState = {}\n\nlocal function reducer(state, action)\n    state = state or initialState\n\n    if action.type == \"setFoo\" then\n        -- Handle the setFoo action\n    elseif action.type == \"setBar\" then\n        -- Handle the setBar action\n    end\n\n    return state\nend\n</code></pre> <p><code>createReducer</code> can replace the chain of <code>if</code> statements in a reducer:</p> <pre><code>local initialState = {}\n\nlocal reducer = createReducer(initialState, {\n    setFoo = function(state, action)\n        -- Handle the setFoo action\n    end,\n\n    setBar = function(state, action)\n        -- Handle the setBar action\n    end\n})\n</code></pre>"},{"location":"api-reference/#roduxmakeactioncreator","title":"Rodux.makeActionCreator","text":"<pre><code>Rodux.makeActionCreator(name, actionGeneratorFunction) -&gt; actionCreator\n</code></pre> <p>A helper function that can be used to make action creators.</p> <p>Action creators are helper objects that will generate actions from provided data and automatically populate the <code>type</code> field.</p> <p>Actions often have a structure that looks like this:</p> <pre><code>local MyAction = {\n    type = \"SetFoo\",\n    value = 1,\n}\n</code></pre> <p>They are often generated by functions that take the action's data as arguments:</p> <pre><code>local function SetFoo(value)\n    return {\n        type = \"SetFoo\",\n        value = value,\n    }\nend\n</code></pre> <p><code>makeActionCreator</code> looks similar, but it automatically populates the action's type with the action creator's name. This makes it easier to keep track of which actions your reducers are responding to:</p> <p>Make an action creator in <code>SetFoo.lua</code>: <pre><code>return makeActionCreator(\"SetFoo\", function(value)\n    -- The action creator will automatically add the 'type' field\n    return {\n        value = value,\n    }\nend)\n</code></pre></p> <p>Then check for that action by name in <code>FooReducer.lua</code>: <pre><code>local SetFoo = require(SetFoo)\n...\nif action.type == SetFoo.name then\n    -- change some state!\nend\n</code></pre></p>"},{"location":"api-reference/#middleware","title":"Middleware","text":"<p>Rodux provides an API that allows changing the way that actions are dispatched called middleware. To attach middleware to a store, pass a list of middleware as the third argument to <code>Store.new</code>.</p> <p>Warn</p> <p>The middleware API changed in #29 -- middleware written against the old API will not work!</p> <p>A single middleware is just a function with the following signature:</p> <pre><code>(nextDispatch, store) -&gt; (action) -&gt; result\n</code></pre> <p>A middleware is a function that accepts the next dispatch function in the middleware chain, as well as the store the middleware is being used with, and returns a new function. That function is called whenever an action is dispatched and can dispatch more actions, log to output, or perform any other side effects!</p> <p>A simple version of Rodux's <code>loggerMiddleware</code> is as easy as:</p> <pre><code>local function simpleLogger(nextDispatch, store)\n    return function(action)\n        print(\"Dispatched action of type\", action.type)\n\n        return nextDispatch(action)\n    end\nend\n</code></pre> <p>Rodux also ships with several middleware that address common use-cases.</p> <p>To apply middleware, pass a list of middleware as the third argument to <code>Store.new</code>:</p> <pre><code>local store = Store.new(reducer, initialState, { simpleLogger })\n</code></pre> <p>Middleware runs from left to right when an action is dispatched. That means that if a middleware does not call <code>nextDispatch</code> when handling an action, any middleware after it will not run.</p> <p>For a more detailed example, see the middleware guide.</p>"},{"location":"api-reference/#roduxloggermiddleware","title":"Rodux.loggerMiddleware","text":"<p>A middleware that logs actions and the new state that results from them.</p> <p><code>loggerMiddleware</code> is useful for getting a quick look at what actions are being dispatched. In the future, Rodux will have tools similar to Redux's DevTools.</p> <pre><code>local store = Store.new(reducer, initialState, { loggerMiddleware })\n</code></pre>"},{"location":"api-reference/#roduxthunkmiddleware","title":"Rodux.thunkMiddleware","text":"<p>A middleware that allows thunks to be dispatched. Thunks are functions that perform asynchronous tasks or side effects, and can dispatch actions.</p> <p><code>thunkMiddleware</code> is comparable to Redux's redux-thunk.</p> <pre><code>local store = Store.new(reducer, initialState, { thunkMiddleware })\n\nstore:dispatch(function(store)\n    print(\"Hello from a thunk!\")\n\n    store:dispatch({\n        type = \"thunkAction\"\n    })\nend)\n</code></pre>"},{"location":"api-reference/#roduxmakethunkmiddleware-unreleased","title":"Rodux.makeThunkMiddleware (unreleased)","text":"<pre><code>Rodux.makeThunkMiddleware(extraArgument) -&gt; thunkMiddleware\n</code></pre> <p>A function that creates a thunk middleware that injects a custom argument when invoking thunks (in addition to the store itself). This is useful for cases like using an API service layer that could be swapped out for a mock service in tests.</p> <pre><code>local myThunkMiddleware = Rodux.makeThunkMiddleware(myCustomArg)\nlocal store = Store.new(reducer, initialState, { myThunkMiddleware })\n\nstore:dispatch(function(store, myCustomArg)\n    print(\"Hello from a thunk with extra argument:\", myCustomArg)\n\n    store:dispatch({\n        type = \"thunkAction\"\n    })\nend)\n</code></pre>"},{"location":"api-reference/#error-reporters","title":"Error Reporters","text":"<p>In version 3.0.0+, the Rodux store can be provided with a custom error reporter. This is a good entry point to enable improved logging, debugging, and analytics. </p> <p>The error reporter interface is an object with two functions:</p>"},{"location":"api-reference/#reportreducererror","title":"reportReducerError","text":"<pre><code>reportReducerError(prevState, action, errorResult) -&gt; ()\n</code></pre> <p>Called when an error is thrown while processing an action through the reducer. If thunk middleware is included, errors encountered while executing thunks will also be caught and reported through this function.</p> <p>The function receives these arguments:</p> <ul> <li><code>prevState</code> - the last known state value for the store. Since this reporter catches errors that occurred before the reducer finished resolving, the <code>prevState</code> value will be equal to the store state before the action was processed</li> <li><code>action</code> - the action that was being processed when the error occurred</li> <li><code>errorResult</code> - an object describing the error that was caught</li> </ul> <p>The default error reporter will simply rethrow the value from the caught errorResult.</p>"},{"location":"api-reference/#reportupdateerror","title":"reportUpdateError","text":"<pre><code>reportUpdateError(prevState, currentState, actionLog, errorResult) -&gt; ()\n</code></pre> <p>Called when an error is thrown while updating listeners subscribed to the store state. Rodux flushes actions on a regular interval rather than synchronously, so there may be several actions queued up before each flush.</p> <p>The last 3 actions that were received before the current flush are provided to the error reporter. This is currently hard coded in the store logic, but could be overridden with an option in the future if it's useful to do so.</p> <p>The function receives these arguments:</p> <ul> <li><code>prevState</code> - the last known state that was flushed to consumers before the update that produced the error</li> <li><code>currentState</code> - the new store state that was being flushed to consumers when the error occurred. Some consumers may have already processed to this new state by the time the reporter is called</li> <li><code>actionLog</code> - an array containing the last three actions that were dispatched to the store, sorted from oldest to newest</li> <li><code>errorResult</code> - an object describing the error that was caught</li> </ul> <p>The default error reporter will simply rethrow the value from the caught errorResult.</p>"},{"location":"debugging/","title":"Debugging","text":"<p>In the future, Rodux will have tools similar to Redux's DevTools and will be documented here. For now, we highly recommend using the <code>loggerMiddleware</code> to observe the <code>state</code> as <code>action</code> objects are dispatched to your <code>store</code>.</p>"},{"location":"example/","title":"Complete Example","text":"<p>The following is an example of a Rodux store that keeps track of the current user's phone number and the names of their friends. It demonstrates the use of the Rodux <code>store</code>, <code>actions</code>, <code>reducers</code>, and <code>middleware</code> in a real world setting. The <code>loggerMiddleware</code> has been included to demonstrate how to include <code>middleware</code> in your <code>store</code> and to provide valuable output in response to dispatched <code>action</code> objects.</p> <p>Info</p> <p>This example assumes that you've successfully installed Rodux into <code>ReplicatedStorage</code> and placed the contents of the following in a LocalScript under <code>StarterPlayer/StarterPlayerScripts</code>!</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Rodux = require(ReplicatedStorage.Rodux)\n\n-- Action creator for the ReceivedNewPhoneNumber action\nlocal function ReceivedNewPhoneNumber(phoneNumber)\n    return {\n        type = \"ReceivedNewPhoneNumber\",\n        phoneNumber = phoneNumber,\n    }\nend\n\n-- Action creator for the MadeNewFriends action\nlocal function MadeNewFriends(listOfNewFriends)\n    return {\n        type = \"MadeNewFriends\",\n        newFriends = listOfNewFriends,\n    }\nend\n\n-- Reducer for the current user's phone number\nlocal phoneNumberReducer = Rodux.createReducer(\"\", {\n    ReceivedNewPhoneNumber = function(state, action)\n        return action.phoneNumber\n    end,\n})\n\n-- Reducer for the current user's list of friends\nlocal friendsReducer = Rodux.createReducer({}, {\n    MadeNewFriends = function(state, action)\n        local newState = {}\n\n        -- Since state is read-only, we copy it into newState\n        for index, friend in ipairs(state) do\n            newState[index] = friend\n        end\n\n        for _, friend in ipairs(action.newFriends) do\n            table.insert(newState, friend)\n        end\n\n        return newState\n    end,\n})\n\nlocal reducer = Rodux.combineReducers({\n    myPhoneNumber = phoneNumberReducer,\n    myFriends = friendsReducer,\n})\n\nlocal store = Rodux.Store.new(reducer, nil, {\n    Rodux.loggerMiddleware,\n})\n\nstore:dispatch(ReceivedNewPhoneNumber(\"15552345678\"))\nstore:dispatch(MadeNewFriends({\n    \"Cassandra\",\n    \"Joe\",\n}))\n\n--[[\n    Expected output to the developer console:\n\n    Action dispatched: {\n        phoneNumber = \"12345678\" (string)\n        type = \"ReceivedNewPhoneNumber\" (string)\n    }\n    State changed to: {\n        myPhoneNumber = \"12345678\" (string)\n        myFriends = {\n        }\n    }\n    Action dispatched: {\n        newFriends = {\n            1 = \"Cassandra\" (string)\n            2 = \"Joe\" (string)\n        }\n        type = \"MadeNewFriends\" (string)\n    }\n    State changed to: {\n        myPhoneNumber = \"12345678\" (string)\n        myFriends = {\n            1 = \"Cassandra\" (string)\n            2 = \"Joe\" (string)\n        }\n    }\n]]\n</code></pre>"},{"location":"withroact/","title":"Usage with Roact","text":"<p>Rodux stands well on its own and does not require any additional libraries. However, Rodux can be particularly useful when developing Roact applications. It is difficult to represent global state in Roact without passing a lot of data up and down the Roact DOM. <code>RoactRodux</code> allows us to connect individual Roact components to our Rodux store, simplifying the management of our application's global state.</p>"},{"location":"advanced/devtools/","title":"Devtools","text":"<p>The fifth argument to <code>Store.new</code> takes a devtools object that you can optionally provide. A devtools object has only two requirements: <code>devtools.__className</code> must be <code>\"Devtools\"</code> and <code>devtools:_hookIntoStore(store)</code> must be a valid function call. Beyond that, your devtools can be anything you need it to be.</p> <p>Devtools can be very useful during development in gathering performance data, providing introspection, debugging, etc. We leave the devtools implementation up to the user in order to support any and all use cases, such as store modification in unit testing, live state inspection plugins, and whatever else you come up with.</p> <p>A simple example of a devtools that profiles and logs:</p> <pre><code>local Devtools = {}\nDevtools.__className = \"Devtools\"\nDevtools.__index = Devtools\n\n-- Creates a new Devtools object\nfunction Devtools.new()\n    local self = setmetatable({\n        _events = table.create(100),\n        _eventsIndex = 0,\n    }, Devtools)\n\n    return self\nend\n\n-- Overwrites the store's reducer and flushHandler with wrapped versions that contain logging and profiling\nfunction Devtools:_hookIntoStore(store)\n    self._store = store\n    self._source = store._source\n\n    self._originalReducer = store._reducer\n    store._reducer = function(state: any, action: any): any\n        local startClock = os.clock()\n        local result = self._originalReducer(state, action)\n        local stopClock = os.clock()\n\n        self:_addEvent(\"Reduce\", {\n            name = action.type or tostring(action),\n            elapsedMs = (stopClock - startClock) * 1000,\n            action = action,\n            state = result,\n        })\n        return result\n    end\n\n    self._originalFlushHandler = store._flushHandler\n    store._flushHandler = function(...)\n        local startClock = os.clock()\n        self._originalFlushHandler(...)\n        local stopClock = os.clock()\n\n        self:_addEvent(\"Flush\", {\n            name = \"@@FLUSH\",\n            elapsedMs = (stopClock - startClock) * 1000,\n            listeners = table.clone(store.changed._listeners),\n        })\n    end\nend\n\n-- Adds an event to the log\n-- Automatically adds event.timestamp and event.source\nfunction Devtools:_addEvent(eventType: \"Reduce\" | \"Flush\", props: { [any]: any })\n    self._eventsIndex = (self._eventsIndex or 0) + 1\n    self._events[self._eventsIndex] = {\n        eventType = eventType,\n        source = self._source,\n        timestamp = DateTime.now().UnixTimestampMillis,\n        props = props,\n    }\nend\n\n-- Returns a shallow copy of the event log\nfunction Devtools:GetLoggedEvents()\n    return table.clone(self._events)\nend\n</code></pre>"},{"location":"advanced/error-reporters/","title":"Error Reporters","text":"<p>When Rodux encounters errors during action processing or when updating consumers, it will rethrow them by default. In some cases, you may want to intercept errors and record them somewhere useful, often with additional context.</p> <p>The <code>Rodux.Store.new</code> function accepts an optional <code>errorReporter</code> object with the following shape: <pre><code>ErrorReporter = {\n    reportReducerError(prevState, action, errorResult) -&gt; (),\n    reportUpdateError(prevState, currentState, actionLog, errorResult) -&gt; (),\n}\n</code></pre></p> <p>The default implementation used by rodux looks like this: <pre><code>local rethrowErrorReporter = {\n    reportReducerError = function(prevState, action, errorResult)\n        error(string.format(\"Received error: %s\\n\\n%s\", errorResult.message, errorResult.thrownValue))\n    end,\n    reportUpdateError = function(prevState, currentState, lastActions, errorResult)\n        error(string.format(\"Received error: %s\\n\\n%s\", errorResult.message, errorResult.thrownValue))\n    end,\n}\n</code></pre></p> <p>In practice, you might use a custom error reporter to send detailed error information to an analytics endpoint: <pre><code>-- This example supposes that we have some utilities for serializing the store\n-- objects that were involved when an error was thrown\nlocal inspectObject = require(MyUtils.inspectObject)\nlocal tableDiff = require(MyUtils.tableDiff)\nlocal sendToAnalyticsBackend = require(MyUtils.sendToAnalyticsBackend)\n\nlocal rethrowErrorReporter = {\n    reportReducerError = function(prevState, action, errorResult)\n        local message = string.format(\n            \"%s\\n\\nAction:\\n%s\\n\\nError contents:\\n%s\",\n            errorResult.message,\n            inspectObject(action),\n            tostring(errorResult.thrownValue)\n        )\n        sendToAnalyticsBackend(message)\n    end,\n    reportUpdateError = function(prevState, currentState, lastActions, errorResult)\n        local message = string.format(\n            \"%s\\n\\n\" ..\n                \"Store changes in the last flush:\\n%s\\n\\n\" ..\n                \"Most recent actions (starting with the oldest):\\n%s\\n\\n\" ..\n                \"Error contents:\\n%s\",\n            errorResult.message,\n            inspectObject(tableDiff(prevState, currentState)),\n            inspectObject(actionLog),\n            tostring(errorResult.thrownValue)\n        )\n        sendToAnalyticsBackend(message)\n    end,\n}\n</code></pre></p>"},{"location":"advanced/middleware/","title":"Middleware","text":"<p>Most of the time, calling <code>Store:dispatch</code> sends incoming <code>action</code> objects directly to the <code>reducer</code> to determine what updates should be made to the <code>state</code>. This is enough for most cases, but some features would be difficult to implement if this was all Rodux provided. For example:</p> <ul> <li>Delayed processing of an <code>action</code>.</li> <li>Logging <code>action</code> objects dispatched to our <code>store</code>.</li> <li>Performing a network request in response to an <code>action</code> and storing the response in the <code>state</code>.</li> </ul> <p>Rodux has the concept of <code>middleware</code> to deal with these sorts of situations.</p> <p>A <code>middleware</code> is a function that accepts the next <code>dispatch</code> function in the <code>middleware</code> chain, as well as the <code>store</code> the <code>middleware</code> is being used with, and returns a new function. That function is called whenever an <code>action</code> is dispatched and can dispatch more <code>actions</code>, log to output, or perform any other side effects! When an <code>action</code> is dispatched, <code>middleware</code> are run in the order they were specified in <code>Store.new</code> from left to right.</p> <p>Here is an example of a <code>middleware</code> that could be used to delay the processing of <code>action</code> objects dispatched to the <code>store</code>.</p> <pre><code>local reducer = function(state, action)\n    -- the body of your reducer\nend\n\nlocal initialState = {}\n\nlocal delayOneSecondMiddleware = function(nextDispatch, store)\n    return function(action)\n        delay(1, function()\n            --[[\n                nextDispatch passes the action to the next middleware provided\n                to the store at initialization or to the reducer if the action\n                has already been processed by all the provided middleware.\n            ]]\n            nextDispatch(action)\n        end)\n    end\nend\n\nlocal store = Rodux.Store.new(reducer, initialState, {\n    delayOneSecondMiddleware,\n})\n</code></pre> <p>Warning</p> <p>If the <code>delayOneSecondMiddleware</code> function did not call <code>nextDispatch</code>, then the <code>action</code> would not be processed by any other <code>middleware</code> in the <code>middleware</code> chain or our <code>reducer</code>!</p> <p>Rodux has two <code>middlewares</code> available to you out of the box. See <code>Middleware</code>, <code>thunkMiddleware</code>, and <code>loggerMiddleware</code> for more details.</p>"},{"location":"advanced/thunks/","title":"Thunks","text":"<p>The <code>thunkMiddleware</code> packaged with Rodux will intercept any <code>action</code> dispatched to our <code>store</code> that is a Lua function and execute that function instead of forwarding our <code>action</code> to the <code>reducer</code>. These functions (also called thunks) have access to the <code>store</code> and are allowed to dispatch <code>action</code> objects themselves as necessary.</p> <pre><code>local reducer = function(state, action)\n    --[[\n        Reducer that handles all actions for our store,\n        including actions of the type \"MadeNewFriends\".\n    ]]\nend\n\nlocal initialState = {}\n\nlocal store = Rodux.Store.new(reducer, initialState, {\n    Rodux.thunkMiddleware,\n})\n\n--[[\n    Our thunkMiddleware will process this action as a thunk\n    since it is a Lua function\n]]\nstore:dispatch(function(store)\n    getAsyncNewFriendsForUser(\"Sarah\", function(result)\n        store:dispatch({\n            type = \"MadeNewFriends\",\n            newFriends = result,\n        })\n    end)\nend)\n</code></pre> <p>Thunks are a simple way to introduce more complex processing of <code>action</code> objects, but you may want to consider creating custom <code>middleware</code> for complex features instead of relying on thunks alone.</p> <p>It is also possible to inject a custom argument into the thunk middleware. This is useful for cases like using an API service layer that could be swapped out for a mock service in tests. This is accomplished by using the <code>Rodux.makeThunkMiddleware</code> API instead:</p> <pre><code>local myThunkMiddleware = Rodux.makeThunkMiddleware(myCustomArg)\nlocal store = Rodux.Store.new(reducer, initialState, {\n    myThunkMiddleware,\n})\n\nstore:dispatch(function(store, myCustomArg)\n    print(\"Hello from a thunk with extra argument:\", myCustomArg)\n    store:dispatch({\n        type = \"thunkAction\"\n    })\nend)\n</code></pre> <p>If multiple values need to be passed in, they can be combined into a single table:</p> <pre><code>local myThunkMiddleware = Rodux.makeThunkMiddleware({\n    [RoactNetworking] = networking,\n    AvatarEditorService = AvatarEditorService,\n})\n</code></pre>"},{"location":"introduction/actions/","title":"Actions","text":"<p>Whenever the <code>state</code> in your <code>store</code> needs to be updated in response to an event, you <code>dispatch</code> an <code>action</code> to your <code>store</code> with any relevant information required to make said update. An <code>action</code> is usually a Lua table with a <code>type</code> field. They are usually created via an action creator Lua module like the following:</p> <pre><code>local function ReceivedNewPhoneNumber(phoneNumber)\n    return {\n        type = \"ReceivedNewPhoneNumber\",\n        phoneNumber = phoneNumber,\n    }\nend\n\nreturn ReceivedNewPhoneNumber\n</code></pre> <p>We can then <code>dispatch</code> an <code>action</code> to our <code>store</code> via <code>Store:dispatch</code> like so:</p> <pre><code>local store = Store.new(function(currentState, action)\n    -- The body of your reducer\nend)\n\nstore:dispatch(ReceivedNewPhoneNumber(\"15552345678\"))\n</code></pre> <p>Info</p> <p>In most cases your <code>action</code> will be sent directly to the <code>reducer</code> to be processed. However, if you specified any <code>middleware</code> when initializing your <code>store</code>, your <code>action</code> might also be processed by that <code>middleware</code>.</p> <p>Additionally, Rodux provides a helper method called <code>makeActionCreator</code> to generate 'action creators'. These are a lot like the <code>ReceivedNewPhoneNumber</code> function above, except for two key differences:</p> <ul> <li>Instead of functions, action creators returned from <code>makeActionCreator</code> are callable tables that also include a <code>name</code> field.</li> <li>Action creators will automatically populate the <code>type</code> field of each action they create using their <code>name</code>.</li> </ul> <p>We can define an action creator like this:</p> <pre><code>return makeActionCreator(\"ReceivedNewPhoneNumber\", function(phoneNumber)\n    return {\n        phoneNumber = phoneNumber,\n    }\nend)\n</code></pre> <p>Since the <code>name</code> of the action creator populates the <code>type</code> of the actions it creates, we can use an action creators <code>name</code> to identify actions that were created by it. As we'll see in the Reducers section, this is helpful for determining which action we're processing:</p> <pre><code>    local MyAction = require(MyAction)\n    ...\n    if action.type == MyAction.name then\n        -- change some state!\n    end\n</code></pre> <p>Info</p> <p>Actions are nothing more than tables with a <code>type</code> field, so there are many ways to generate them! If <code>makeActionCreator</code> doesn't work for your project, you can always generate actions and action creators however you like!</p>"},{"location":"introduction/installation/","title":"Installation","text":"<p>There are two supported ways to get started with Rodux.</p> <p>For our examples, we'll install <code>Rodux</code> to <code>ReplicatedStorage</code>. In practice, it's okay to install Rodux anywhere you want!</p>"},{"location":"introduction/installation/#method-1-model-file-roblox-studio","title":"Method 1: Model File (Roblox Studio)","text":"<ul> <li>Download the <code>rbxmx</code> model file attached to the latest release from the GitHub releases page.</li> <li>Insert the model into Studio into a place like <code>ReplicatedStorage</code></li> </ul>"},{"location":"introduction/installation/#method-2-filesystem","title":"Method 2: Filesystem","text":"<ul> <li>Copy the <code>src</code> directory into your codebase</li> <li>Rename the folder to <code>Rodux</code></li> <li>Use a plugin like Rojo to sync the files into a place</li> </ul>"},{"location":"introduction/motivation/","title":"Motivation","text":"<p>As applications become more complex it can be difficult to manage the state of our application in a way that is transparent and compartmentalized. State changes caused by network responses and user input become difficult to follow as our business logic gets spread out between an increasing number of models and views, producing unpredictable and undesirable results. Rodux tries to address this problem by following three core principles.</p>"},{"location":"introduction/motivation/#single-source-of-truth","title":"Single Source of Truth","text":"<p>By collecting all of our application's state in a single object, we can quickly inspect the entirety of the data backing our business logic. We will no longer need to track down data models squirrelled away in disparate parts of our code base.</p>"},{"location":"introduction/motivation/#state-is-read-only","title":"State is Read-only","text":"<p>All changes to our single state object are accomplished by dispatching actions to our store, so which part of our code caused what changes to our underlying data will be completely transparent and reproducible. Features that were once difficult like undo/redo become trivial when all changes to our data are controlled via a single, consistent interface.</p>"},{"location":"introduction/motivation/#changes-are-made-with-pure-functions","title":"Changes Are Made With Pure Functions","text":"<p>Actions dispatched to our store will be processed by pure functions called reducers. These reducers simply take an action and our store's current state as input and output the store's new state in response to that action. These functions have no side effects and give us a single location to put all of our business logic instead of spreading that business logic out over numerous views and models.</p> <p>That's all there is to it! The API and tools Rodux provides are relatively simple, but solve many of the most common problems that occur in complex, asynchronous applications by introducing a single paradigm for all of our data management.</p>"},{"location":"introduction/reducers/","title":"Reducers","text":"<p>When you initialize your <code>store</code> with <code>Store.new</code>, you provide a single function called a <code>reducer</code> which will consume any <code>action</code> dispatched to your <code>store</code> and create a new <code>state</code> object based on the current <code>state</code> of your <code>store</code>.</p> <pre><code>local phoneNumberReducer = function(state, action)\n    if action.type == \"ReceivedNewPhoneNumber\" then\n        return action.phoneNumber\n    end\n\n    return state\nend\n</code></pre> <p>Note that <code>state</code> is never actually modified by our <code>reducer</code>. The <code>state</code> of our <code>store</code> is read-only, so our <code>reducer</code> must construct a new <code>state</code> object in response to the received <code>action</code>.</p> <p>For complex applications, it is often useful to break down the global <code>reducer</code> you provide to the <code>store</code> into a set of smaller <code>reducer</code> functions, each of which is responsible for a portion of the <code>state</code>.</p> <pre><code>local friendsReducer = function(state, action)\n    --[[\n        The state might be nil the first time this reducer is executed.\n        In that case, we need to initialize our state to be the empty table.\n    ]]\n    state = state or {}\n\n    if action.type == \"MadeNewFriends\" then\n        local newState = {}\n\n        -- Since state is read-only, we copy it into newState\n        for index, friend in ipairs(state) do\n            newState[index] = friend\n        end\n\n        for _, friend in ipairs(action.newFriends)\n            table.insert(newState, friend)\n        end\n\n        return newState\n    end\n\n    return state\nend\n\n--[[\n    note that the reducer for our entire application is defined by a table of\n    sub-reducers where each sub-reducer is responsible for one portion of the\n    overall state.\n]]\nlocal reducer = function(state, action)\n    return {\n        myPhoneNumber = phoneNumberReducer(state.myPhoneNumber, action),\n        myFriends = friendsReducer(state.myFriends, action),\n    }\nend\n</code></pre> <p>Alternatively, you can use <code>Rodux.createReducer</code> and <code>Rodux.combineReducers</code> to generate the same code as seen above. Using <code>Rodux.createReducer</code> and <code>Rodux.combineReducers</code> to create your <code>reducer</code> functions isn't as verbose and is less prone to developer error.</p> <pre><code>local phoneNumberReducer = Rodux.createReducer(nil, {\n    ReceivedNewPhoneNumber = function(state, action)\n        return action.phoneNumber\n    end,\n})\n\nlocal friendsReducer = Rodux.createReducer({}, {\n    MadeNewFriends = function(state, action)\n        local newState = {}\n\n        -- Since state is read-only, we copy it into newState\n        for index, friend in ipairs(state) do\n            newState[index] = friend\n        end\n\n        for _, friend in ipairs(action.friends)\n            table.insert(newState, friend)\n        end\n\n        return newState\n    end,\n})\n\nlocal reducer = Rodux.combineReducers({\n    myPhoneNumber = phoneNumberReducer,\n    myFriends = friendsReducer,\n})\n</code></pre>"},{"location":"introduction/store/","title":"The Store","text":"<p>The <code>store</code> is comprised of three parts and is your main entry point for all things Rodux. It is created via <code>Store.new</code>.</p>"},{"location":"introduction/store/#state","title":"State","text":"<p>This is the object that contains all of the data backing the business logic of your application. It is usually represented as a Lua table and it can be read via <code>Store:getState</code>.</p> <pre><code>local exampleState = {\n    myPhoneNumber = \"15552345678\",\n    myFriends = {\n        \"Joe\",\n        \"Cassandra\",\n    },\n}\n</code></pre>"},{"location":"introduction/store/#reducer","title":"Reducer","text":"<p>This is a pure function that takes in an <code>action</code> object and the current state of your <code>store</code> and outputs a new state in response to the <code>action</code>. Reducers are often broken down into many individual pure functions, each of which modifies one portion of the state. You provide your global <code>reducer</code> to the <code>store</code> during initialization via <code>Store.new</code>. See the Reducer page for more details.</p>"},{"location":"introduction/store/#dispatcher","title":"Dispatcher","text":"<p>This is the function of the <code>store</code> that handles incoming <code>action</code> objects and forwards them to your <code>reducer</code>. If you have applied any <code>middleware</code> to your <code>store</code>, the <code>middleware</code> will wrap this <code>dispatcher</code> function and reassign it such that the <code>action</code> will be passed through all of the <code>middleware</code> you provided to your <code>store</code> before forwarding the <code>action</code> object to the <code>reducer</code>. You can provide <code>middleware</code> to the <code>store</code> during initialization via <code>Store.new</code>.</p> <pre><code>local store = Rodux.Store.new(function(action, currentState)\n    -- The body of your reducer\nend)\n\nlocal state = store:getState()\n</code></pre>"}]}